2019
-------------------------------------------------------
Q1. Write a MIPS assembly program to do the following and save it with the filename Q1_util.asm:
a) Write a subprogram to exit from an assembly program [05 marks]
b) Write a subprogram to print a String [05 marks]
c) Write a subprogram to prompt an Integer [05 marks]
d) Write a subprogram to print an Integer [05 marks]
e) Write a subprogram to print a Tab [05 marks]


# Q1_util.asm
.text

exit_program:
    li $v0, 10
    syscall
    jr $ra

print_string:
    li $v0, 4
    syscall
    jr $ra

prompt_integer:
    li $v0, 5
    syscall
    jr $ra

print_integer:
    li $v0, 1
    syscall
    jr $ra

print_tab:
    li $a0, '\t'
    li $v0, 11
    syscall
    jr $ra
-------------------------------------------------------



Q2. Translate the following pseudo code into MIPS assembly. Use register direct access when addressing the memory. [30 marks]
main() {
    int miles = prompt("Enter the number of miles driven: ");
    int gallons = prompt("Enter the number of gallons used: ");
    int mpg = miles / gallons;
    output("Your mpg = " + mpg);
}


.data
prompt_miles:   .asciiz "Enter the number of miles driven: "
prompt_gallons: .asciiz "Enter the number of gallons used: "
output_msg:     .asciiz "Your mpg = "
newline:        .asciiz "\n"
err_msg:        .asciiz "Error: Gallons cannot be zero.\n"

.text
.globl main
main:
    
    li $v0, 4
    la $a0, prompt_miles
    syscall

    li $v0, 5
    syscall
    move $t0, $v0       

    
    li $v0, 4
    la $a0, prompt_gallons
    syscall

    li $v0, 5
    syscall
    move $t1, $v0       

    
    beqz $t1, div_zero_error

    
    div $t0, $t1
    mflo $t2            

    
    li $v0, 4
    la $a0, output_msg
    syscall

    
    li $v0, 1
    move $a0, $t2
    syscall

   
    li $v0, 4
    la $a0, newline
    syscall

   
    li $v0, 10
    syscall

div_zero_error:
    li $v0, 4
    la $a0, err_msg
    syscall
    li $v0, 10
    syscall


-------------------------------------------------------


Q3. Write a MIPS program that prompts the user to enter a positive integer and prints whether it is even or odd. [15 marks]
Hint: Use the Q1_util.asm to make the assembly program's length shorter.

.data
prompt_msg: .asciiz "Enter a positive integer: "
even_msg:   .asciiz "The number is even.\n"
odd_msg:    .asciiz "The number is odd.\n"


.text
.globl main

main:
    la $a0, prompt_msg
    jal print_string
    
    jal prompt_integer
    move $t0, $v0
    
    andi $t1, $t0, 1
    beqz $t1, is_even
    
    la $a0, odd_msg
    jal print_string
    j exit
    
is_even:
    la $a0, even_msg
    jal print_string
    
exit:
    jal exit_program
    
    
.include "Q1_util.asm"

-------------------------------------------------------
    


Q4. Write an MIPS assembly program that mimics a calculator. The program should take two integers and the operation to be performed as input. The operations to be performed should be displayed as a Menu and the user is also prompt to select the operation number from the menu. It should then output the numbers, the operator, and the result. (For division, if the denominator is zero, output an appropriate message.) Some sample inputs and outputs follow: [30 marks]
Sample Input & Output:
Enter Number 1: 5
Enter Number 2: 7
Menu:
1 - Addition
2 - Subtraction
3 - Multiplication
4 - Division (Quotient)
5 - Modulus (Reminder)
Select the operation from the Menu: 3
5 x 7 = 35


.data
prompt1: .asciiz "Enter Number 1: "
prompt2: .asciiz "Enter Number 2: "
menu:    .asciiz "\nMenu:\n1 - Addition\n2 - Subtraction\n3 - Multiplication\n4 - Division (Quotient)\n5 - Modulus (Remainder)\nSelect the operation from the Menu: "
add_sym: .asciiz " + "
sub_sym: .asciiz " - "
mul_sym: .asciiz " x "
div_sym: .asciiz " / "
mod_sym: .asciiz " % "
eq_sym:  .asciiz " = "
newline: .asciiz "\n"
err_msg: .asciiz "Error: Division or modulus by zero is not allowed.\n"

.text
.globl main
main:
   
    li $v0, 4
    la $a0, prompt1
    syscall

    li $v0, 5
    syscall
    move $t0, $v0      

    
    li $v0, 4
    la $a0, prompt2
    syscall

    li $v0, 5
    syscall
    move $t1, $v0     

    
    li $v0, 4
    la $a0, menu
    syscall

    
    li $v0, 5
    syscall
    move $t2, $v0     

    
    li $v0, 1
    move $a0, $t0
    syscall

    
    li $t5, 1
    beq $t2, $t5, addition
    li $t5, 2
    beq $t2, $t5, subtraction
    li $t5, 3
    beq $t2, $t5, multiplication
    li $t5, 4
    beq $t2, $t5, division
    li $t5, 5
    beq $t2, $t5, modulus

    j end_program  


addition:
    li $v0, 4
    la $a0, add_sym
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    li $v0, 4
    la $a0, eq_sym
    syscall

    add $t3, $t0, $t1

    li $v0, 1
    move $a0, $t3
    syscall
    j end_program


subtraction:
    li $v0, 4
    la $a0, sub_sym
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    li $v0, 4
    la $a0, eq_sym
    syscall

    sub $t3, $t0, $t1
    li $v0, 1
    move $a0, $t3
    syscall
    j end_program


multiplication:
    li $v0, 4
    la $a0, mul_sym
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    li $v0, 4
    la $a0, eq_sym
    syscall

    mul $t3, $t0, $t1
    li $v0, 1
    move $a0, $t3
    syscall
    j end_program


division:
    beqz $t1, div_error

    li $v0, 4
    la $a0, div_sym
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    li $v0, 4
    la $a0, eq_sym
    syscall

    div $t0, $t1
    mflo $t3     # Quotient
    li $v0, 1
    move $a0, $t3
    syscall
    j end_program

modulus:
    beqz $t1, div_error

    li $v0, 4
    la $a0, mod_sym
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    li $v0, 4
    la $a0, eq_sym
    syscall

    div $t0, $t1
    mfhi $t3     # Remainder
    li $v0, 1
    move $a0, $t3
    syscall
    j end_program


div_error:
    li $v0, 4
    la $a0, newline
    syscall
    li $v0, 4
    la $a0, err_msg
    syscall
    j end_program

end_program:
    li $v0, 10
    syscall

-------------------------------------------------------



2018
-------------------------------------------------------
Q1. Write an assembly language program that prompts the user to input two single-digit numbers from the keyboard. Then display both numbers and results of their summation, subtraction, multiplication, and division.  
[25 Marks]  


.data
prompt1: .asciiz "Enter first single-digit number: "
prompt2: .asciiz "Enter second single-digit number: "
msg1:    .asciiz "First number: "
msg2:    .asciiz "\nSecond number: "
summsg:  .asciiz "\nSum: "
submsg:  .asciiz "\nSubtraction: "
mulmsg:  .asciiz "\nMultiplication: "
divmsg:  .asciiz "\nDivision: "
newline: .asciiz "\n"

.text
.globl main
main:
    
    li $v0, 4
    la $a0, prompt1
    syscall
    li $v0, 5
    syscall
    move $t0, $v0  

    li $v0, 4
    la $a0, prompt2
    syscall
    li $v0, 5
    syscall
    move $t1, $v0  


    li $v0, 4
    la $a0, msg1
    syscall
    li $v0, 1
    move $a0, $t0
    syscall

    li $v0, 4
    la $a0, msg2
    syscall
    li $v0, 1
    move $a0, $t1
    syscall

   
    add $t2, $t0, $t1
    li $v0, 4
    la $a0, summsg
    syscall
    li $v0, 1
    move $a0, $t2
    syscall

    
    sub $t2, $t0, $t1
    li $v0, 4
    la $a0, submsg
    syscall
    li $v0, 1
    move $a0, $t2
    syscall

 
    mul $t2, $t0, $t1
    li $v0, 4
    la $a0, mulmsg
    syscall
    li $v0, 1
    move $a0, $t2
    syscall

   
    div $t0, $t1
    mflo $t2
    li $v0, 4
    la $a0, divmsg
    syscall
    li $v0, 1
    move $a0, $t2
    syscall

    li $v0, 10
    syscall

-------------------------------------------------------

Q2. Write an assembly language program to print the numbers 9 to 1 using loops.  
[25 Marks]  

.data
newline: .asciiz "\n"

.text
.globl main
main:
    li $t0, 9  # Counter

loop:
    li $v0, 1
    move $a0, $t0
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    subi $t0, $t0, 1
    bgtz $t0, loop

    li $v0, 10
    syscall
-------------------------------------------------------


Q3. Write an assembly language program that displays the smallest of three single-digit numbers.  
Sample output:  
Enter a number: 7  
Enter a second number: 2  
Enter a third number: 5  
Smallest of three numbers is: 2  

.data
msg1: .asciiz "Enter a number: "
msg2: .asciiz "Enter a second number: "
msg3: .asciiz "Enter a third number: "
res:  .asciiz "Smallest of three numbers is: "
newline: .asciiz "\n"

.text
.globl main
main:
   
    li $v0, 4
    la $a0, msg1
    syscall
    li $v0, 5
    syscall
    move $t0, $v0

    
    li $v0, 4
    la $a0, msg2
    syscall
    li $v0, 5
    syscall
    move $t1, $v0

    
    li $v0, 4
    la $a0, msg3
    syscall
    li $v0, 5
    syscall
    move $t2, $v0

    
    ble $t0, $t1, firstSmaller
    move $t3, $t1
    j compareWithT2

firstSmaller:
    move $t3, $t0

compareWithT2:
    ble $t3, $t2, done
    move $t3, $t2

done:
    li $v0, 4
    la $a0, res
    syscall
    li $v0, 1
    move $a0, $t3
    syscall

    li $v0, 10
    syscall

-------------------------------------------------------




2017

-------------------------------------------------------
Q1. Write assembly language program for the following:  
a. Create and open a file named myfile.txt  
b. Writes a text 'Welcome to TCEUSL' in this file.  
c. Reads from the file and stores the data into a buffer named info.  
d. Displays the text as stored in info.  


.data
filename: .asciiz "myfile.txt"
text:     .asciiz "Welcome to TCEUSL"
info:     .space 50
newline:  .asciiz "\nContent read from file:\n"

.text
.globl main
main:
    
    li $v0, 13             
    la $a0, filename       
    li $a1, 1             
    li $a2, 0              
    syscall
    move $s0, $v0         

    
    li $v0, 15             
    move $a0, $s0       
    la $a1, text          
    li $a2, 19            
    syscall

    
    li $v0, 16            
    move $a0, $s0
    syscall

    
    li $v0, 13
    la $a0, filename
    li $a1, 0             
    li $a2, 0
    syscall
    move $s0, $v0

   
    li $v0, 14             
    move $a0, $s0
    la $a1, info
    li $a2, 50            
    syscall

   
    li $v0, 16
    move $a0, $s0
    syscall

   
    li $v0, 4
    la $a0, newline
    syscall

   
    li $v0, 4
    la $a0, info
    syscall

   
    li $v0, 10
    syscall

-------------------------------------------------------



Q2. Write an assembly language program to print descending rows of stars using loops.  
Sample output:  
******  
*****  
****  
*** 
** 
*

.data
star: .asciiz "*"
newline: .asciiz "\n"

.text
.globl main
main:
    li $t0, 6       

outer_loop:
    li $t1, 0        

inner_loop:
    bge $t1, $t0, end_inner
    li $v0, 4
    la $a0, star
    syscall
    addi $t1, $t1, 1
    j inner_loop

end_inner:
    li $v0, 4
    la $a0, newline
    syscall
    subi $t0, $t0, 1
    bgtz $t0, outer_loop

    li $v0, 10
    syscall

-------------------------------------------------------


Q3. Write an assembly language program that create an array to store two values. Displays the summation, subtraction, multiplication and division of them.  
Sample output:  
Enter a digit: 8  
Enter a second digit: 4  
The sum is: 12  
The Subtraction is: 4  
The Multiplication is: 24  
The Division is: 2  

.data
prompt1: .asciiz "Enter a digit: "
prompt2: .asciiz "Enter a second digit: "
summsg:  .asciiz "The sum is: "
submsg:  .asciiz "The Subtraction is: "
mulmsg:  .asciiz "The Multiplication is: "
divmsg:  .asciiz "The Division is: "
newline: .asciiz "\n"

.align 2           # Ensure word-aligned address (4 bytes)
arr: .space 8      # Space for two 4-byte integers (2 x 4 = 8 bytes)

.text
.globl main
main:
    
    li $v0, 4
    la $a0, prompt1
    syscall

    li $v0, 5
    syscall
    sw $v0, arr       

    
    li $v0, 4
    la $a0, prompt2
    syscall

    li $v0, 5
    syscall
    sw $v0, arr+4      

    
    lw $t0, arr       
    lw $t1, arr+4      

    
    add $t2, $t0, $t1
    li $v0, 4
    la $a0, summsg
    syscall
    li $v0, 1
    move $a0, $t2
    syscall
    li $v0, 4
    la $a0, newline
    syscall

    
    sub $t2, $t0, $t1
    li $v0, 4
    la $a0, submsg
    syscall
    li $v0, 1
    move $a0, $t2
    syscall
    li $v0, 4
    la $a0, newline
    syscall

  
    mul $t2, $t0, $t1
    li $v0, 4
    la $a0, mulmsg
    syscall
    li $v0, 1
    move $a0, $t2
    syscall
    li $v0, 4
    la $a0, newline
    syscall

   
    div $t0, $t1       
    mflo $t2            
    li $v0, 4
    la $a0, divmsg
    syscall
    li $v0, 1
    move $a0, $t2
    syscall
    li $v0, 4
    la $a0, newline
    syscall

    
    li $v0, 10
    syscall

-------------------------------------------------------


2016
-------------------------------------------------------
Q1. Write assembly language code to display the largest of three given numbers, which are stored in variables. The numbers should be two digit. The three variables num1, num2 and num3, have values 47, 72 and 31 respectively.  
[20 Marks]  

.data
num1: .word 47
num2: .word 72
num3: .word 31
msg:  .asciiz "Largest number is: "

.text
.globl main
main:
    lw $t0, num1       
    lw $t1, num2       
    lw $t2, num3      

    
    bgt $t0, $t1, check13
    move $t3, $t1      
    j check23
check13:
    move $t3, $t0      

check23:
    bgt $t3, $t2, done
    move $t3, $t2

done:
    li $v0, 4
    la $a0, msg
    syscall

    li $v0, 1
    move $a0, $t3
    syscall

    li $v0, 10
    syscall

-------------------------------------------------------


Q2. Write assembly language code for printing the number from 3 to 9 on the screen using loops.  
[20 Marks]  

.data
newline: .asciiz "\n"

.text
.globl main
main:
    li $t0, 3        

loop:
    li $v0, 1
    move $a0, $t0
    syscall

    li $v0, 4        
    la $a0, newline
    syscall

    addi $t0, $t0, 1
    li $t1, 10       
    blt $t0, $t1, loop

    li $v0, 10
    syscall

-------------------------------------------------------


Q3. Write assembly language code for defining a 3 element array and stores three values. Display the product of those values.  
[20 Marks]  

.data
arr: .word 2, 3, 4
msg: .asciiz "Product is: "

.text
.globl main
main:
    la $t0, arr       
    lw $t1, 0($t0)    
    lw $t2, 4($t0)    
    lw $t3, 8($t0)    

    mul $t4, $t1, $t2
    mul $t4, $t4, $t3

    li $v0, 4
    la $a0, msg
    syscall

    li $v0, 1
    move $a0, $t4
    syscall

    li $v0, 10
    syscall
-------------------------------------------------------



Q4. Factorial of a number, n is given by the equation:  
fact (n) = n * fact (n-1); where n >0, fact (1)=1  
Write assembly language code to calculate factorial for the input of n from the keyboard.  
[20 Marks]  

.data
prompt: .asciiz "Enter a number: "
result: .asciiz "Factorial is: "

.text
.globl main
main:
    li $v0, 4
    la $a0, prompt
    syscall

    li $v0, 5
    syscall
    move $t0, $v0     
    li $t1, 1         

loop:
    blez $t0, end
    mul $t1, $t1, $t0
    subi $t0, $t0, 1
    j loop

end:
    li $v0, 4
    la $a0, result
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    li $v0, 10
    syscall

-------------------------------------------------------


Q5. Write assembly language code to print the following pattern using loops.  
KKKKKK  
KKKKK  
KKKK  
KKK  
KK  
K  
[20 Marks]  


.data
newline: .asciiz "\n"
charK:   .asciiz "K"

.text
.globl main
main:
    li $t0, 6        

row_loop:
    li $t1, 0    

print_K:
    bge $t1, $t0, print_nl
    li $v0, 4
    la $a0, charK
    syscall

    addi $t1, $t1, 1
    j print_K

print_nl:
    li $v0, 4
    la $a0, newline
    syscall

    subi $t0, $t0, 1
    bgtz $t0, row_loop

    li $v0, 10
    syscall

-------------------------------------------------------








# Problem Sheet
-------------------------------------------------------

Q1.Consider the following pseudo code program, where the user is prompted for a value of x
and the program prints out the results of the equation 5ùë•
2 + 2ùë• + 3. Write a complete
MIPS assembly language program for this.
main{
int x = prompt("Enter a value for x: ");
int y = 5 * x * x + 2 * x + 3;
print("The result is: " + y);
}


.data
    prompt:     .asciiz "Enter a value for x: "
    result_msg: .asciiz "The result is: "
    newline:    .asciiz "\n"

.text
.globl main

main:
    
    li $v0, 4              
    la $a0, prompt
    syscall

    li $v0, 5              
    syscall
    move $t0, $v0          

   
    mul $t1, $t0, $t0      

    
    li $t2, 5
    mul $t2, $t1, $t2      

    
    li $t3, 2
    mul $t3, $t0, $t3      

   
    add $t4, $t2, $t3      
    addi $t4, $t4, 3     

    
    li $v0, 4
    la $a0, result_msg
    syscall

   
    li $v0, 1
    move $a0, $t4
    syscall

    
    li $v0, 4
    la $a0, newline
    syscall

   
    li $v0, 10
    syscall

-------------------------------------------------------

Q2.Write programs to evaluate the following expressions. The user should enter the variables,
and the program should print back an answer. Prompt the user for all variables in the
expression, and print the results in a meaningful manner. The results should be as
accurate as possible.
a) 5ùë• + 3ùë¶ + ùëß
b) ((5ùë• + 3ùë¶ + ùëß) / 2) ‚àó 3
c) x^3 + 2x^2 + 3x + 4
d) (4ùë• / 3) ‚àó y


.data
    prompt_x: .asciiz "Enter value for x: "
    prompt_y: .asciiz "Enter value for y: "
    prompt_z: .asciiz "Enter value for z: "
    
    result_a: .asciiz "Result of a) 5x + 3y + z = "
    result_b: .asciiz "Result of b) ((5x + 3y + z) / 2) * 3 = "
    result_c: .asciiz "Result of c) x^3 + 2x^2 + 3x + 4 = "
    result_d: .asciiz "Result of d) (4x / 3) * y = "
    newline:  .asciiz "\n"

.text
.globl main

main:
    
    li $v0, 4
    la $a0, prompt_x
    syscall

    li $v0, 5
    syscall
    move $t0, $v0       

    
    li $v0, 4
    la $a0, prompt_y
    syscall

    li $v0, 5
    syscall
    move $t1, $v0       

    
    li $v0, 4
    la $a0, prompt_z
    syscall

    li $v0, 5
    syscall
    move $t2, $v0       

    
    li $t3, 5
    mul $t3, $t0, $t3   

    li $t4, 3
    mul $t4, $t1, $t4   

    add $t5, $t3, $t4   
    add $t5, $t5, $t2   

    li $v0, 4
    la $a0, result_a
    syscall

    li $v0, 1
    move $a0, $t5
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    
 
    li $t6, 2
    div $t5, $t6
    mflo $t7            

    li $t8, 3
    mul $t9, $t7, $t8   

    li $v0, 4
    la $a0, result_b
    syscall

    li $v0, 1
    move $a0, $t9
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    
    mul $s0, $t0, $t0       
    mul $s1, $s0, $t0       

    li $s2, 2
    mul $s2, $s0, $s2       

    li $s3, 3
    mul $s3, $t0, $s3      

    add $s4, $s1, $s2       
    add $s4, $s4, $s3      
    addi $s4, $s4, 4        

    li $v0, 4
    la $a0, result_c
    syscall

    li $v0, 1
    move $a0, $s4
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    
    li $s5, 4
    mul $s5, $t0, $s5       

    li $s6, 3
    div $s5, $s6
    mflo $s7                

    mul $t9, $s7, $t1       

    li $v0, 4
    la $a0, result_d
    syscall

    li $v0, 1
    move $a0, $t9
    syscall

    li $v0, 4
    la $a0, newline
    syscall


    li $v0, 10
    syscall
-------------------------------------------------------

Q3. Implement the rem operator using only div, mfhi, and mflo
# Assume x in $t0 and y in $t1
div $t0, $t1   
mfhi $t2       
-------------------------------------------------------



Q4.Enter the following two instructions in MARS, and assemble them. What differences do
you notice? Are the results the same? Will one run faster than the other? Explain what you
observe.
addiu $t0, $zero, 60000
ori $t0, $zero, 60000
Observation:

Both store the value 60000 in $t0
addiu performs signed addition ‚Üí can be used for both signed/unsigned
ori is a bitwise OR operation ‚Üí works like immediate move for unsigned


| Instruction | Type       | Sign Handling   | Performance                       |
| ----------- | ---------- | --------------- | --------------------------------- |
| `addiu`     | Arithmetic | Can handle sign | Slightly slower                   |
| `ori`       | Logical    | Unsigned only   | Slightly faster in some pipelines |

-------------------------------------------------------


Q5.Write a complete assembly language program that inputs two numbers and displays their
sum and difference.
.data
    prompt1: .asciiz "Enter first number: "
    prompt2: .asciiz "Enter second number: "
    sum_msg: .asciiz "Sum = "
    diff_msg: .asciiz "Difference = "
    newline: .asciiz "\n"

.text
.globl main
main:
    
    li $v0, 4
    la $a0, prompt1
    syscall

    li $v0, 5
    syscall
    move $t0, $v0     

    
    li $v0, 4
    la $a0, prompt2
    syscall

    li $v0, 5
    syscall
    move $t1, $v0     

    
    add $t2, $t0, $t1

    li $v0, 4
    la $a0, sum_msg
    syscall

    li $v0, 1
    move $a0, $t2
    syscall

    li $v0, 4
    la $a0, newline
    syscall

   
    sub $t3, $t0, $t1

    li $v0, 4
    la $a0, diff_msg
    syscall

    li $v0, 1
    move $a0, $t3
    syscall

   
    li $v0, 10
    syscall


-------------------------------------------------------

Q6.Write a complete assembly language program that inputs two numbers and displays their
multiplication, quotient and reminder.

.data
    prompt1: .asciiz "Enter first number: "
    prompt2: .asciiz "Enter second number: "
    prod_msg: .asciiz "Product = "
    quot_msg: .asciiz "Quotient = "
    rem_msg:  .asciiz "Remainder = "
    newline:  .asciiz "\n"

.text
.globl main
main:
   
    li $v0, 4
    la $a0, prompt1
    syscall

    li $v0, 5
    syscall
    move $t0, $v0

   
    li $v0, 4
    la $a0, prompt2
    syscall

    li $v0, 5
    syscall
    move $t1, $v0

    
    mul $t2, $t0, $t1

    li $v0, 4
    la $a0, prod_msg
    syscall

    li $v0, 1
    move $a0, $t2
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    
    div $t0, $t1
    mflo $t3      
    mfhi $t4      

    li $v0, 4
    la $a0, quot_msg
    syscall

    li $v0, 1
    move $a0, $t3
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    li $v0, 4
    la $a0, rem_msg
    syscall

    li $v0, 1
    move $a0, $t4
    syscall

    
    li $v0, 10
    syscall

-------------------------------------------------------

Q7.Write a complete MIPS assembly language that computes a rectangle's area and perimeter
given the width and height. The width and height are read from the standard input after
prompting the user, and then the program computes the area, and perimeter and prints them
on the standard output.

.data
    prompt_w: .asciiz "Enter width: "
    prompt_h: .asciiz "Enter height: "
    area_msg: .asciiz "Area = "
    peri_msg: .asciiz "Perimeter = "
    newline:  .asciiz "\n"

.text
.globl main
main:
   
    li $v0, 4
    la $a0, prompt_w
    syscall

    li $v0, 5
    syscall
    move $t0, $v0   

   
    li $v0, 4
    la $a0, prompt_h
    syscall

    li $v0, 5
    syscall
    move $t1, $v0   

    
    mul $t2, $t0, $t1

    li $v0, 4
    la $a0, area_msg
    syscall

    li $v0, 1
    move $a0, $t2
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    
    add $t3, $t0, $t1
    sll $t3, $t3, 1     

    li $v0, 4
    la $a0, peri_msg
    syscall

    li $v0, 1
    move $a0, $t3
    syscall

    
    li $v0, 10
    syscall

-------------------------------------------------------

Q8.Write the following HLL program in MIPS assembly language
int i = prompt("Enter your number");
int j = i % 2;
print("A result of 0 is even, a result of 1 is odd: result = " + j);
Hint: No need to use if else structure


.data
    prompt: .asciiz "Enter your number: "
    result_msg: .asciiz "A result of 0 is even, a result of 1 is odd. Result = "
    newline: .asciiz "\n"

.text
.globl main

main:
    
    li $v0, 4
    la $a0, prompt
    syscall

    
    li $v0, 5
    syscall
    move $t0, $v0  

   
    li $t1, 2
    div $t0, $t1
    mfhi $t2       

    
    li $v0, 4
    la $a0, result_msg
    syscall

    li $v0, 1
    move $a0, $t2
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    
    li $v0, 10
    syscall

-------------------------------------------------------


Q9.Write an MIPS assembly language program to implement the following tasks.
e) Prompt the length, width and height of a rectangular wooden box
f) Read the length, width and height of a rectangular wooden box
g) Compute the surface area and volume of the box
h) Display the surface area and the volume of the box
Hint: Surface Area = 2(length x width + length x height + width x height),
Area = length x width x height


.data
    promptL: .asciiz "Enter length: "
    promptW: .asciiz "Enter width: "
    promptH: .asciiz "Enter height: "
    msgVolume: .asciiz "Volume = "
    msgSA: .asciiz "Surface Area = "
    newline: .asciiz "\n"

.text
.globl main
main:
   
    li $v0, 4
    la $a0, promptL
    syscall
    li $v0, 5
    syscall
    move $t0, $v0   

    
    li $v0, 4
    la $a0, promptW
    syscall
    li $v0, 5
    syscall
    move $t1, $v0   

    
    li $v0, 4
    la $a0, promptH
    syscall
    li $v0, 5
    syscall
    move $t2, $v0   

    
    mul $t3, $t0, $t1    
    mul $t3, $t3, $t2    

    li $v0, 4
    la $a0, msgVolume
    syscall

    li $v0, 1
    move $a0, $t3
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    
    mul $t4, $t0, $t1    
    mul $t5, $t0, $t2    
    mul $t6, $t1, $t2    

    add $t7, $t4, $t5
    add $t7, $t7, $t6    
    sll $t7, $t7, 1      

    li $v0, 4
    la $a0, msgSA
    syscall

    li $v0, 1
    move $a0, $t7
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    li $v0, 10
    syscall

-------------------------------------------------------



Q10. Write a MIPS program that executes the statement: s = (a + b) ‚Äì (c + 101), where a, b,
and c are user provided integer inputs, and s is computed and printed as an output. Answer
the following:
a) Suppose the user enters a = 5, b = 10, and c = -30, what is the expected value of s?
b) Which instruction in your program computed the value of s and which register is used?
c) What is the address of this instruction in memory?
d) Put a breakpoint at this instruction and write the value of the register used for computing
s in decimal and hexadecimal.


.data
    promptA: .asciiz "Enter a: "
    promptB: .asciiz "Enter b: "
    promptC: .asciiz "Enter c: "
    resultMsg: .asciiz "s = (a + b) - (c + 101) = "
    newline: .asciiz "\n"

.text
.globl main

main:
    
    li $v0, 4
    la $a0, promptA
    syscall
    li $v0, 5
    syscall
    move $t0, $v0   

   
    li $v0, 4
    la $a0, promptB
    syscall
    li $v0, 5
    syscall
    move $t1, $v0   

    
    li $v0, 4
    la $a0, promptC
    syscall
    li $v0, 5
    syscall
    move $t2, $v0   

   
    add $t3, $t0, $t1       
    addi $t4, $t2, 101      
    sub $t5, $t3, $t4        

   
    li $v0, 4
    la $a0, resultMsg
    syscall

    li $v0, 1
    move $a0, $t5
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    li $v0, 10
    syscall

-------------------------------------------------------


a) If a = 5, b = 10, c = -30  
Then:  
s = (5 + 10) - (-30 + 101)  
  = 15 - 71  
  = -56  

b) Which instruction computes s?  
sub $t5, $t3, $t4  
This computes s, and the result is stored in $t5  

c) What is the address of this instruction in memory?  
If .text starts at 0x00400000, and assuming each instruction is 4 bytes:  
instruction ‚Üí address = 0x0040005c
  
d) Breakpoint at that instruction:  
$t5 will contain -56  
Decimal = -56  
Hex     = 0xFFFFFFC8

-------------------------------------------------------


1. Write a MIPS program that prompts a positive integer from a user
and prints whether it is even or odd.

# Q1: Prompt an integer and print whether it is Even or Odd
.data
    prompt_msg: .asciiz "Enter a positive integer: "
    even_msg:   .asciiz "The number is Even.\n"
    odd_msg:    .asciiz "The number is Odd.\n"
    invalid_msg:.asciiz "Invalid input. Enter a positive integer.\n"

.text
.globl main

main:
    
    li $v0, 4
    la $a0, prompt_msg
    syscall

   
    li $v0, 5
    syscall
    move $t0, $v0       

   
    blez $t0, print_invalid

   
    andi $t1, $t0, 1    
    beqz $t1, print_even 
    j print_odd

print_even:
    li $v0, 4
    la $a0, even_msg
    syscall
    j exit

print_odd:
    li $v0, 4
    la $a0, odd_msg
    syscall
    j exit

print_invalid:
    li $v0, 4
    la $a0, invalid_msg
    syscall

exit:
    li $v0, 10
    syscall

-------------------------------------------------------

2. Translate this HLL code segment to MIPS. Write a complete MIPS
program
if (i != j)
    h = i + j;
else
    h = i - j;


# Q2: Translate if (i != j) h = i + j; else h = i - j;

.text
.globl main

main:
   
    li $t0, 10      
    li $t1, 5      

    bne $t0, $t1, not_equal    
    sub $t2, $t0, $t1         
    j done

not_equal:
    add $t2, $t0, $t1        

done:
    
    li $v0, 1
    move $a0, $t2
    syscall

    
    li $v0, 10
    syscall


-------------------------------------------------------


Exercise: Translate the following HLL statements into assembly instructions.
‚úÖ 1. if(i == j) f = g + h; f = f - i;
-------------------------------------------------------

    beq $t0, $t1, equal_branch
    j skip_add

equal_branch:
    add $t4, $t2, $t3        

skip_add:
    sub $t4, $t4, $t0     
-------------------------------------------------------


‚úÖ 2. if(i == j) f = g + h; else f = f - i;
-------------------------------------------------------

    beq $t0, $t1, do_add
    sub $t4, $t4, $t0       
    j done

do_add:
    add $t4, $t2, $t3     

done:
-------------------------------------------------------


‚úÖ 3. Power-of-2 while loop
int pow = 1;
int x = 0;
while (pow != 128) {
    pow = pow * 2;
    x = x + 1;
}


-------------------------------------------------------

    li $t0, 1        # pow = 1
    li $t1, 0        # x = 0

loop:
    li $t2, 128
    beq $t0, $t2, end_loop
    sll $t0, $t0, 1      # pow = pow * 2 (multiply by 2 using shift)
    addi $t1, $t1, 1     # x = x + 1
    j loop

end_loop:

-------------------------------------------------------

‚úÖ 4. For loop sum of 0 to 9

int sum = 0;
int i;
for(i = 0; i != 10; i = i + 1) {
    sum = sum + i;
}

-------------------------------------------------------
    li $t0, 0        # sum = 0
    li $t1, 0        # i = 0

for_loop:
    li $t2, 10
    beq $t1, $t2, end_for
    add $t0, $t0, $t1    # sum = sum + i
    addi $t1, $t1, 1     # i = i + 1
    j for_loop

end_for:
-------------------------------------------------------


‚úÖ 5. Fibonacci-style while loop
int n = 10;
int f1 = 1, f2 = 1;
while (n != 0) {
    f1 = f1 + f2;
    f2 = f1 - f2;
    n = n - 1;
}
// result is f1

-------------------------------------------------------
    li $t0, 10       # n = 10
    li $t1, 1        # f1 = 1
    li $t2, 1        # f2 = 1

fib_loop:
    beqz $t0, end_fib
    add $t1, $t1, $t2    # f1 = f1 + f2
    sub $t2, $t1, $t2    # f2 = f1 - f2
    subi $t0, $t0, 1     # n = n - 1
    j fib_loop

end_fib:
    # $t1 now holds the result

-------------------------------------------------------
n = prompt("enter the value to calculate the sum up to: ") ;
total = 0; # Initial the total variable for sum
for (i = 0; i < n; i++)
{
total = total + i ; // total+=i;
}
print("Total = " + total); 



.data
    prompt_msg: .asciiz "Enter the value to calculate the sum up to: "
    result_msg: .asciiz "Total = "

.text
.globl main

main:
    
    li $v0, 4
    la $a0, prompt_msg
    syscall

    
    li $v0, 5
    syscall
    move $t0, $v0     

    
    li $t1, 0         
    li $t2, 0         

for_loop:
    
    beq $t2, $t0, end_loop

   
    add $t1, $t1, $t2

   
    addi $t2, $t2, 1

    j for_loop

end_loop:
    
    li $v0, 4
    la $a0, result_msg
    syscall

    
    li $v0, 1
    move $a0, $t1
    syscall

    
    li $v0, 10
    syscall


-------------------------------------------------------
int i = prompt("Enter an integer, or -1 to exit");
while (i != -1) {
    print("You entered " + i);
    i = prompt("Enter an integer, or -1 to exit");
}


.text
.globl main

main:
    la $a0, prompt
    li $v0, 4
    syscall

    li $v0, 5
    syscall
    move $s0, $v0

start_loop:
    li $t1, -1
    beq $s0, $t1, end_loop

    la $a0, output
    li $v0, 4
    syscall

    move $a0, $s0
    li $v0, 1
    syscall

    la $a0, prompt
    li $v0, 4
    syscall

    li $v0, 5
    syscall
    move $s0, $v0

    j start_loop

end_loop:
    li $v0, 10
    syscall

.data
prompt: .asciiz "\nEnter an integer, -1 to stop: "
output: .asciiz "\nYou entered: "



-------------------------------------------------------

if (grade > 100) || grade < 0){
print("Grade must be between 0..100")
} elseif (grade >= 90){
print("Grade is A")
} elseif (grade >= 80){
print("Grade is B")
} elseif (grade >= 70){
print("Grade is C")
} elseif (grade >= 60){
print("Grade is D")
} else{
print("Grade is F")
}

.text
.globl main

main:
    li $v0, 4
    la $a0, prompt_msg
    syscall

    li $v0, 5
    syscall
    move $s0, $v0

    slti $t1, $s0, 0
    sgt  $t2, $s0, 100
    or   $t1, $t1, $t2
    beqz $t1, grade_A

    la $a0, InvalidInput
    j Print_End

grade_A:
    sge $t1, $s0, 90
    beqz $t1, grade_B
    la $a0, OutputA
    j Print_End

grade_B:
    sge $t1, $s0, 80
    beqz $t1, grade_C
    la $a0, OutputB
    j Print_End

grade_C:
    sge $t1, $s0, 70
    beqz $t1, grade_D
    la $a0, OutputC
    j Print_End

grade_D:
    sge $t1, $s0, 60
    beqz $t1, else
    la $a0, OutputD
    j Print_End

else:
    la $a0, OutputF

Print_End:
    li $v0, 4
    syscall

    li $v0, 10
    syscall

.data
prompt_msg:   .asciiz "Enter your mark (0-100): "
InvalidInput: .asciiz "Invalid input! Number must be between 0 and 100.\n"
OutputA:      .asciiz "Grade is A\n"
OutputB:      .asciiz "Grade is B\n"
OutputC:      .asciiz "Grade is C\n"
OutputD:      .asciiz "Grade is D\n"
OutputF:      .asciiz "Grade is F\n"

-------------------------------------------------------

if (num > 0) {
print("Number is positive") }
else {
print("Number is negative")
} 


.data
positive_msg: .asciiz "Number is positive\n"
negative_msg: .asciiz "Number is negative\n"
prompt:      .asciiz "Enter a number: "

.text
.globl main

main:
    
    li $v0, 4
    la $a0, prompt
    syscall

    
    li $v0, 5
    syscall
    move $t0, $v0        

    
    blez $t0, print_negative

print_positive:
    li $v0, 4
    la $a0, positive_msg
    syscall
    j exit

print_negative:
    li $v0, 4
    la $a0, negative_msg
    syscall

exit:
    li $v0, 10
    syscall


-------------------------------------------------------

Check if (x > 0) && ((x % 2) == 0)

.data
msg_true:  .asciiz "x is positive and even\n"
msg_false: .asciiz "x does not meet condition\n"
prompt:    .asciiz "Enter an integer x: "

.text
.globl main

main:
    # Prompt user
    li $v0, 4
    la $a0, prompt
    syscall

    # Read input x
    li $v0, 5
    syscall
    move $t0, $v0      # x in $t0

    # Check x > 0
    blez $t0, print_false

    # Check x % 2 == 0
    andi $t1, $t0, 1   # t1 = x & 1 (least significant bit)
    bnez $t1, print_false  # if odd, jump to false

    # Condition met
    li $v0, 4
    la $a0, msg_true
    syscall
    j exit

print_false:
    li $v0, 4
    la $a0, msg_false
    syscall

exit:
    li $v0, 10
    syscall



-------------------------------------------------------

Check if (x > 0) && ((x % 2) == 0) && (x < 10)

.data
msg_true:  .asciiz "x is positive, even, and less than 10\n"
msg_false: .asciiz "x does not meet condition\n"
prompt:    .asciiz "Enter an integer x: "

.text
.globl main

main:
    # Prompt user
    li $v0, 4
    la $a0, prompt
    syscall

    # Read input x
    li $v0, 5
    syscall
    move $t0, $v0

    # Check x > 0
    blez $t0, print_false

    # Check x % 2 == 0
    andi $t1, $t0, 1
    bnez $t1, print_false

    # Check x < 10
    li $t2, 10
    bge $t0, $t2, print_false

    # Condition met
    li $v0, 4
    la $a0, msg_true
    syscall
    j exit

print_false:
    li $v0, 4
    la $a0, msg_false
    syscall

exit:
    li $v0, 10
    syscall

-------------------------------------------------------
if (num > 0) {
    print("Number is positive");
}


.data
prompt:         .asciiz "Enter a number: "
positive_msg:   .asciiz "Number is positive\n"

.text
.globl main

main:
    li $v0, 4
    la $a0, prompt
    syscall

    li $v0, 5
    syscall
    move $t0, $v0      # num in $t0

    blez $t0, exit     # if num <= 0, skip printing

    li $v0, 4
    la $a0, positive_msg
    syscall

exit:
    li $v0, 10
    syscall

-------------------------------------------------------

main() {
       static volatile int miles = prompt("Enter the number of miles driven:");
       static volatile int gallons = prompt("Enter the number of gallons used:");
       static volatile int mpg = miles / gallons;
       output("Your mpg = " + mpg);
}

.data
prompt_miles:   .asciiz "Enter the number of miles driven: "
prompt_gallons: .asciiz "Enter the number of gallons used: "
output_text:    .asciiz "Your mpg = "
miles:          .word 0
gallons:        .word 0
mpg:            .word 0

.text
.globl main
main:

    
    li $v0, 4              
    la $a0, prompt_miles
    syscall

    li $v0, 5              
    syscall
    sw $v0, miles          

   
    li $v0, 4               
    la $a0, prompt_gallons
    syscall

    li $v0, 5              
    syscall
    sw $v0, gallons         

   
    lw $t0, miles
    lw $t1, gallons

   
    div $t0, $t1            
    mflo $t2             
    sw $t2, mpg            

    
    li $v0, 4               
    la $a0, output_text
    syscall

    li $v0, 1               
    lw $a0, mpg
    syscall

    
    li $v0, 10              
    syscall
-------------------------------------------------------
Check if three sides form a right triangle
.data
prompt1: .asciiz "Enter side 1: "
prompt2: .asciiz "Enter side 2: "
prompt3: .asciiz "Enter side 3: "
yesMsg:  .asciiz "It's a right triangle!\n"
noMsg:   .asciiz "Not a right triangle.\n"

.text
.globl main
main:
    # --- Input side 1 ---
    li $v0, 4
    la $a0, prompt1
    syscall
    li $v0, 5
    syscall
    move $t0, $v0         # t0 = side1

    # --- Input side 2 ---
    li $v0, 4
    la $a0, prompt2
    syscall
    li $v0, 5
    syscall
    move $t1, $v0         # t1 = side2

    # --- Input side 3 ---
    li $v0, 4
    la $a0, prompt3
    syscall
    li $v0, 5
    syscall
    move $t2, $v0         # t2 = side3

    # Compute squares
    mul $t3, $t0, $t0     # t3 = side1^2
    mul $t4, $t1, $t1     # t4 = side2^2
    mul $t5, $t2, $t2     # t5 = side3^2

    # Check all three combinations:
    # 1) t3 == t4 + t5
    add $t6, $t4, $t5
    beq $t3, $t6, print_yes

    # 2) t4 == t3 + t5
    add $t6, $t3, $t5
    beq $t4, $t6, print_yes

    # 3) t5 == t3 + t4
    add $t6, $t3, $t4
    beq $t5, $t6, print_yes

    j print_no

print_yes:
    li $v0, 4
    la $a0, yesMsg
    syscall
    j exit

print_no:
    li $v0, 4
    la $a0, noMsg
    syscall

exit:
    li $v0, 10
    syscall



-------------------------------------------------------

for (i = 0; i < 10; i++) {
    a = a + b;
}

    li   $t0, 0         # i = 0
loop:
    bge  $t0, 10, end  # if i >= 10, jump to end
    add  $s0, $s0, $s1 # a = a + b
    addi $t0, $t0, 1   # i++
    j    loop
end:


-------------------------------------------------------


li $v0,4 #load service number for string print in $v0 
la $a0, prompt_string # load address of string to be printed into $a0 
syscall 
li $v0,5 # read an integer 
syscall # read value goes into v0 
move $t1,$v0 # save integer in temp 1 (t1) 
li $v0,4 #load service number for string print in $v0 
syscall 
li $v0,5 # read an integer 
syscall # read value goes into v0 
move $t2,$v0 # save integer in temp 2 (t2) 
add $t3,$t1,$t2 #$t3 <- contents of $t1 + contents of $t2 
li $v0,4 #load service number for string print in $v0 
la $a0, result_string # load address of string to be printed into $a0 
syscall 
li $v0,1 # print an integer 
move $a0,$t3 # integer to print goes in a0 
syscall 
 
# the null-terminated string must be defined in data segment 
.data 
prompt_string: .asciiz "Enter a value: " 
result_string: .asciiz "The sum is



Which registers have a non-zero value at this point?

$v0: Contains the last syscall service number used

$a0: Contains the address of the last string printed

$t1, $t2, $t3: Contain the two input values and their sum

$pc: Program counter (always non-zero during execution)


What the value of the PC indicates:
The PC (Program Counter) register indicates the memory address of the next instruction to be executed by the processor. In MARS, it shows where the program is currently executing in memory.


About 0x notation:
The "0x" notation indicates that the following number is in hexadecimal (base-16) format. The 8-digit numbers are memory addresses represented in hexadecimal.


Text Segment panel columns:
a. Bkpt: Breakpoint column (for setting debugging breakpoints)
b. Address: Memory address of the instruction
c. Code: Hexadecimal representation of the machine code instruction
d. Basic: Basic assembly representation of the instruction
e. Source: Original source code line


Starting addresses:
a. The starting address of the program (Text Segment) is typically 0x00400000 in MARS.
b. The starting address of the Data Segment is typically 0x10010000 in MARS.


Why non-zero values in Data Segment:
The first 7 words in the Data Segment contain non-zero values because:

- They store the null-terminated strings (prompt_string and result_string) defined in the .data section
- Strings are stored as sequences of ASCII values (non-zero for most characters)
- The assembler may pad the data segment with additional non-zero values for alignment

